#!/usr/bin/env bash
# Clipboard helper: copy (default), paste (-p), optional keyvalue sync (-n) and encryption (-e).

set -euo pipefail

# Program used to copy to the system clipboard. Override with COP_CMD if defined in the environment.
COP_CMD="${COP_CMD:-pbcopy}"

# keyvalue.immanuel.co app key; this is an opaque identifier used to update/get values.
KEYVALUE_APP_KEY="pk1vk7oj"

# Predetermined key under which to store the clipboard content in the key-value service.
KEYVALUE_KEY="cop"

# ANSI colour codes (via $'\033[...') for consistent colour rendering across shells.
GREEN=$'\033[32m'
CYAN=$'\033[36m'
YELLOW=$'\033[33m'
RED=$'\033[31m'
BOLD=$'\033[1m'
RESET=$'\033[0m'

mode=""
bytes=0
LAST_PAYLOAD=""
PASTE_USED=""
copy_flag=0
info_flag=0

# Logging helper for uniform prefix.
log() {
  printf "ðŸ“‹ %s[cop]%s %s\n" "$BOLD$RED" "$RESET" "$*" >&2
}

show_usage() {
  cat >&2 <<EOF_USAGE

ðŸ“‹ ${BOLD}${GREEN}cop${RESET} â€” clipboard helper

${YELLOW}Usage:${RESET}
  cop [${CYAN}OPTIONS${RESET}] [FILE...]

${YELLOW}Options:${RESET}
  -p, --paste      Paste mode: print data from clipboard or remote
  -n, --network    Use keyvalue.immanuel.co for remote sync
  -e, --encrypt    Encrypt or decrypt using \$COP_SECRET (AESâ€‘256â€‘CBC)
  -c, --copy       Copy fetched data to local clipboard (relevant with -n)
  -i, --info       Show info about available copy/pasteboard commands
  -h, --help       Show this help message

${YELLOW}Notes:${RESET}
  â€¢ Short options may be concatenated; for example, -pne is the same as -p -n -e.
  â€¢ Without any options, cop reads from stdin or files and copies to the clipboard.
  â€¢ When using -n, data is sent to or fetched from the remote keyâ€‘value store.
  â€¢ Encryption only affects the remote payload; your local clipboard remains plaintext.
  â€¢ A symlink named 'pas' acts like running 'cop -p'.

${YELLOW}Examples:${RESET}
  echo "hello" | cop          â€” copy plain text to clipboard
  cop file.txt                â€” copy contents of file.txt
  cop -n file.txt             â€” copy and sync file to remote
  cop -n -e file.txt          â€” encrypt then sync file to remote
  cop -p                      â€” paste from local clipboard
  cop -p -n                   â€” paste from remote store
  cop -p -n -e                â€” paste and decrypt remote content
  cop -p -n -e -c             â€” paste, decrypt, and copy to clipboard
  cop -p output.txt           â€” paste clipboard contents into output.txt

EOF_USAGE
}

# Read data from stdin and record the payload.
copy_from_stdin() {
  mode="stdin"
  local data
  data="$(cat)"
  bytes=$(printf "%s" "$data" | wc -c | tr -d ' ')
  LAST_PAYLOAD="$data"
}

# Read data from supplied files and record the payload.
copy_from_files() {
  mode="files"
  local data
  data="$(cat -- "$@")"
  bytes=$(printf "%s" "$data" | wc -c | tr -d ' ')
  LAST_PAYLOAD="$data"
}

# Environment detection helpers for X11/Wayland, used to choose paste command.
is_wayland() { [[ -n "${WAYLAND_DISPLAY:-}" && -S "/run/user/$(id -u)/${WAYLAND_DISPLAY}" ]]; }
is_x11() { [[ -n "${DISPLAY:-}" ]]; }

# Candidate commands for pasting from the system clipboard.
PASTE_CMDS=(
  wl-paste
  pbpaste
  powershell.exe
  xclip
  xsel
  termux-clipboard-get
  getclip
)

find_paste_cmd() {
  for cmd in "${PASTE_CMDS[@]}"; do
    command -v "$cmd" >/dev/null 2>&1 || continue
    case "$cmd" in
    wl-paste) is_wayland || continue ;;
    xclip | xsel) is_x11 || continue ;;
    esac
    echo "$cmd"
    return 0
  done
  return 1
}

# Retrieve text from the local clipboard using an appropriate utility.
get_local_clipboard() {
  local paste_cmd data
  if ! paste_cmd=$(find_paste_cmd); then
    log "Error: no working paste utility found (checked: ${PASTE_CMDS[*]})"
    exit 1
  fi
  PASTE_USED="$paste_cmd"
  case "$paste_cmd" in
  wl-paste | pbpaste | termux-clipboard-get | getclip)
    data="$($paste_cmd)"
    ;;
  powershell.exe)
    data="$($paste_cmd -Command "Get-Clipboard")"
    ;;
  xclip)
    data="$($paste_cmd -selection clipboard -o)"
    ;;
  xsel)
    data="$($paste_cmd --clipboard --output)"
    ;;
  esac
  printf "%s" "$data"
}

# Encode data as base64 without newlines.  Uses the available base64 implementation.
base64_encode() {
  local input
  input=$(cat)
  if command -v base64 >/dev/null 2>&1; then
    if encoded=$(printf "%s" "$input" | base64 --wrap=0 2>/dev/null); then
      printf "%s" "$encoded"
      return 0
    elif encoded=$(printf "%s" "$input" | base64 2>/dev/null | tr -d '\n'); then
      printf "%s" "$encoded"
      return 0
    fi
  fi
  # Fallback to Python for encoding if base64 is not available or fails.
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PYEOF' 2>/dev/null
import sys, base64
data = sys.stdin.read().encode()
print(base64.b64encode(data).decode(), end='')
PYEOF
    <<<"$input"
    return 0
  fi
  # If we cannot encode, return the original string; this risks URL issues but ensures progress.
  printf "%s" "$input"
}

# Crossâ€‘platform base64 decode helper. Attempts multiple flags and falls back to Python.
decode_base64() {
  local input
  input=$(cat)
  # Try GNU base64 --decode
  if command -v base64 >/dev/null 2>&1; then
    if out=$(printf "%s" "$input" | base64 --decode 2>/dev/null); then
      printf "%s" "$out"
      return 0
    fi
    # Try BSD base64 -D
    if out=$(printf "%s" "$input" | base64 -D 2>/dev/null); then
      printf "%s" "$out"
      return 0
    fi
    # Try Linux base64 -d
    if out=$(printf "%s" "$input" | base64 -d 2>/dev/null); then
      printf "%s" "$out"
      return 0
    fi
  fi
  # Try Python base64 decode
  if command -v python3 >/dev/null 2>&1; then
    if out=$(
      python3 - <<'PYEOF' 2>/dev/null
import sys, base64, binascii
data = sys.stdin.read().strip()
try:
    sys.stdout.write(base64.b64decode(data).decode('utf-8'))
except Exception:
    pass
PYEOF
      <<<"$input"
    ); then
      if [[ -n "$out" ]]; then
        printf "%s" "$out"
        return 0
      fi
    fi
  fi
  # Fallback: return raw input
  printf "%s" "$input"
  return 0
}

# Send data to keyvalue.immanuel.co using the configured app key and key.
# The value is base64â€‘encoded and passed as a path segment to avoid encoding issues.
send_to_keyvalue() {
  local data=$1
  local encoded
  encoded=$(printf "%s" "$data" | base64_encode | tr -d '\n')
  local url="https://keyvalue.immanuel.co/api/KeyVal/UpdateValue/${KEYVALUE_APP_KEY}/${KEYVALUE_KEY}/${encoded}"
  local tmp_body status
  tmp_body=$(mktemp 2>/dev/null || echo "/tmp/cop_kv_body_$$")
  status=$(curl -s -o "$tmp_body" -w "%{http_code}" -X POST -d '' "$url" || echo "000")
  if [[ "$status" != "200" && "$status" != "201" ]]; then
    log "KeyValue POST failed (status $status) to $url"
    log "KeyValue response body:"
    sed 's/^/  /' "$tmp_body" >&2
    rm -f "$tmp_body"
    return 1
  fi
  rm -f "$tmp_body"
  printf "ðŸ“‹ ${BOLD}${GREEN}Synced${RESET} to ${CYAN}keyvalue.immanuel.co${RESET} (app key: %s, key: %s).\n" "$KEYVALUE_APP_KEY" "$KEYVALUE_KEY" >&2
  return 0
}

# Fetch data from keyvalue.immanuel.co using the configured app key and key.
# Attempts to base64â€‘decode the stored value.  If decoding fails, the raw string is returned.
fetch_from_keyvalue() {
  local url="https://keyvalue.immanuel.co/api/KeyVal/GetValue/${KEYVALUE_APP_KEY}/${KEYVALUE_KEY}"
  local tmp_body status
  tmp_body=$(mktemp 2>/dev/null || echo "/tmp/cop_kv_get_$$")
  status=$(curl -s -o "$tmp_body" -w "%{http_code}" "$url" || echo "000")
  if [[ "$status" != "200" ]]; then
    log "KeyValue GET failed (status $status) from $url"
    log "KeyValue response body:"
    sed 's/^/  /' "$tmp_body" >&2
    rm -f "$tmp_body"
    return 1
  fi
  local raw
  raw=$(cat "$tmp_body")
  rm -f "$tmp_body"
  # Trim carriage returns and newlines. Without trimming, the surrounding quote
  # detection below may fail when the API includes a trailing newline.
  raw=$(printf "%s" "$raw" | tr -d '\r\n')
  # If the value is surrounded by double quotes, strip them. This handles
  # cases where the service returns plain strings (e.g. "floop").
  if [[ -n "$raw" ]]; then
    # Determine the first and last characters without using negative offsets.
    local first_char last_char len
    len=${#raw}
    first_char="${raw:0:1}"
    last_char="${raw:$(($len - 1)):1}"
    if [[ "$first_char" == '"' && "$last_char" == '"' ]]; then
      # Remove the surrounding quotes safely using length-based slicing.
      raw="${raw:1:$(($len - 2))}"
    fi
  fi
  # If the result is empty, return nothing
  if [[ -z "$raw" ]]; then
    printf ""
    return 0
  fi
  # Attempt to decode base64; if decoding fails, decode_base64 prints raw
  printf "%s" "$raw" | decode_base64
  return 0
}

ensure_crypto() {
  if ! command -v openssl >/dev/null 2>&1; then
    log "Error: openssl not found; -e cannot be used on this system"
    exit 1
  fi
  if [[ -z "${COP_SECRET:-}" ]]; then
    log "Error: COP_SECRET not set; -e requires a symmetric secret in COP_SECRET"
    exit 1
  fi
}

encrypt_data() {
  ensure_crypto
  openssl enc -aes-256-cbc -salt -pass env:COP_SECRET -base64
}

decrypt_data() {
  ensure_crypto
  openssl enc -d -aes-256-cbc -salt -pass env:COP_SECRET -base64
}

# Prompt user before syncing to the public key-value store.  Displays a truncated preview.
confirm_public_send() {
  # $1: plaintext payload to display in the prompt
  # $2: encryption flag (1 if encryption is enabled, 0 otherwise)
  local payload="$1"
  local enc_flag="${2:-0}"
  local max=128
  local preview
  local len=${#payload}
  if ((len > max)); then
    preview="${payload:0:max}..."
  else
    preview="$payload"
  fi
  if ((enc_flag)); then
    printf "ðŸ“‹ ðŸ”’ This text will be encrypted before upload. Unencrypted preview:\n" >&2
  else
    printf "ðŸ“‹ ${YELLOW}Warning:${RESET} You are about to copy the following text to a public key-value store:\n" >&2
  fi
  printf "    \"%s\"\n" "$preview" >&2
  printf "ðŸ“‹ Proceed? [y/N] " >&2
  local ans=""
  if [[ -r /dev/tty ]]; then
    read -r ans </dev/tty || ans=""
  fi
  case "$ans" in
  y | Y | yes | YES)
    return 0
    ;;
  *)
    printf "ðŸ“‹ ${BOLD}${RED}[cop] Aborted keyvalue sync at user request.${RESET}\n" >&2
    return 1
    ;;
  esac
}

# Print information about available clipboard helpers and which ones are in use.
print_info() {
  printf "ðŸ“‹ Clipboard helpers info:\n" >&2
  # Report copy command
  if command -v "$COP_CMD" >/dev/null 2>&1; then
    printf "  Copy command (COP_CMD): %s (available)\n" "$COP_CMD" >&2
  else
    printf "  Copy command (COP_CMD): %s (not found)\n" "$COP_CMD" >&2
  fi
  printf "\n  Paste commands:\n" >&2
  local cmd availability
  for cmd in "${PASTE_CMDS[@]}"; do
    availability="not found"
    if command -v "$cmd" >/dev/null 2>&1; then
      # Check environment restrictions
      availability="available"
      case "$cmd" in
      wl-paste)
        if ! is_wayland; then
          availability="available but Wayland not detected"
        fi
        ;;
      xclip | xsel)
        if ! is_x11; then
          availability="available but X11 not detected"
        fi
        ;;
      esac
    fi
    printf "    %-20s %s\n" "$cmd" "$availability" >&2
  done
  # Determine which paste command would be used
  local current
  current=$(find_paste_cmd 2>/dev/null || echo "none")
  printf "\n  Current paste command: %s\n" "$current" >&2
}

# Paste operation: fetch from keyvalue or local clipboard, optionally decrypt, and print.
paste_clipboard() {
  local use_network=$1
  local do_encrypt=$2
  local copy_local=$3
  local raw out
  if ((use_network)); then
    if ! raw="$(fetch_from_keyvalue)"; then
      log "Failed to fetch from keyvalue; aborting paste."
      exit 1
    fi
    printf "ðŸ“‹ ${BOLD}${GREEN}Pasted${RESET} from ${CYAN}keyvalue.immanuel.co${RESET} (app key: %s, key: %s).\n" "$KEYVALUE_APP_KEY" "$KEYVALUE_KEY" >&2
  else
    raw="$(get_local_clipboard)"
    printf "ðŸ“‹ ${BOLD}${GREEN}Pasted${RESET} from ${CYAN}clipboard${RESET} via ${CYAN}%s${RESET}.\n" "$PASTE_USED" >&2
  fi
  if ((do_encrypt)); then
    out="$(printf "%s" "$raw" | decrypt_data)"
  else
    out="$raw"
  fi
  # Copy to local clipboard if requested
  if ((copy_local)); then
    printf "%s" "$out" | "$COP_CMD"
  fi
  # Print decrypted/plain text to stdout
  printf "%s" "$out"
}

main() {
  local paste=0
  local network=0
  local encrypt=0
  local script_name
  script_name=$(basename "$0")
  # If invoked as "pas", act as if -p was passed
  if [[ "$script_name" == "pas" ]]; then
    set -- -p "$@"
  fi
  # Parse options, accepting long names and combined short options (-pne)
  while [[ $# -gt 0 ]]; do
    local arg="$1"
    case "$arg" in
    --help)
      show_usage
      exit 0
      ;;
    --info)
      info_flag=1
      shift
      continue
      ;;
    --paste)
      paste=1
      shift
      continue
      ;;
    --network)
      network=1
      shift
      continue
      ;;
    --encrypt)
      encrypt=1
      shift
      continue
      ;;
    --copy)
      copy_flag=1
      shift
      continue
      ;;
    --)
      shift
      break
      ;;
    -*)
      # Handle combined short options like -pne
      local i
      for ((i = 1; i < ${#arg}; i++)); do
        local ch="${arg:i:1}"
        case "$ch" in
        p) paste=1 ;;
        n) network=1 ;;
        e) encrypt=1 ;;
        c) copy_flag=1 ;;
        i) info_flag=1 ;;
        h)
          show_usage
          exit 0
          ;;
        *)
          log "Unknown option: -$ch"
          show_usage
          exit 1
          ;;
        esac
      done
      shift
      continue
      ;;
    *)
      break
      ;;
    esac
  done
  # Determine whether to copy to local clipboard.  By default, copying
  # occurs for local operations.  For network operations (-n), copying is
  # disabled unless the user explicitly requested it (-c/--copy).
  local copy_local=1
  if ((network)); then
    copy_local=0
  fi
  if ((copy_flag)); then
    copy_local=1
  fi
  # Emit a Marvin-esque sigh if -c is specified without -n (redundant)
  if ((copy_flag)) && ((network == 0)); then
    log "Marvin sighs: you specified -c without -nâ€¦ I was going to copy anyway."
  fi

  # If --info was requested, display helper information and exit
  if ((info_flag)); then
    print_info
    exit 0
  fi

  if ((paste)); then
    # If a file argument is provided, write the pasted content to that file.
    local output_file=""
    if (($# > 1)); then
      log "Error: only one output file may be specified for paste mode"
      exit 1
    elif (($# == 1)); then
      output_file="$1"
      shift
    fi
    # Fetch/decrypt the content
    local out
    out=$(paste_clipboard "$network" "$encrypt" "$copy_local")
    # Write to file or stdout
    if [[ -n "$output_file" ]]; then
      # Write output to specified file
      printf "%s" "$out" >"$output_file"
      # Report success
      local out_bytes
      out_bytes=$(printf "%s" "$out" | wc -c | tr -d ' ')
      printf "ðŸ“‹ ${BOLD}${GREEN}Written${RESET} to ${CYAN}%s${RESET} (%s byte(s)).\n" "$output_file" "$out_bytes" >&2
    else
      printf "%s" "$out"
    fi
    exit 0
  fi
  # Copy mode: gather payload
  if ! [[ -t 0 ]]; then
    copy_from_stdin
  elif [[ $# -gt 0 ]]; then
    copy_from_files "$@"
  else
    show_usage
    exit 1
  fi
  local plain_payload="$LAST_PAYLOAD"
  local payload_to_send
  if ((encrypt)); then
    payload_to_send="$(printf "%s" "$plain_payload" | encrypt_data)"
  else
    payload_to_send="$plain_payload"
  fi
  # Copy to local clipboard if enabled.  If encryption is on, copy the encrypted
  # string; otherwise copy the plaintext.
  if ((copy_local)); then
    local clipboard_data
    if ((encrypt)); then
      clipboard_data="$payload_to_send"
    else
      clipboard_data="$plain_payload"
    fi
    printf "%s" "$clipboard_data" | "$COP_CMD"
  fi
  # Optionally sync to keyvalue
  if ((network)); then
    # Show confirm prompt with plaintext preview and lock icon if encrypted
    if confirm_public_send "$plain_payload" "$encrypt"; then
      send_to_keyvalue "$payload_to_send" || true
    fi
  fi
  # Feedback message
  if [[ "$mode" == "stdin" ]]; then
    printf "ðŸ“‹ ${BOLD}${GREEN}Copied${RESET} from ${CYAN}stdin${RESET} (%s byte(s)).\n" "$bytes"
  else
    printf "ðŸ“‹ ${BOLD}${GREEN}Copied${RESET} from ${CYAN}files${RESET} (%s file(s), %s byte(s)).\n" "$#" "$bytes"
  fi
}

main "$@"
