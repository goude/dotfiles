#!/usr/bin/env bash
set -euo pipefail

# Program used to copy to clipboard. Override with: COP_CMD="..." cop ...
COP_CMD="${COP_CMD:-pbcopy}"

GREEN='\033[32m'
CYAN='\033[36m'
BOLD='\033[1m'
RESET='\033[0m'
YELLOW='\033[33m'

mode=""
bytes=0

copy_from_stdin() {
  mode="stdin"
  # Read all stdin once, copy, and count bytes.
  # This keeps behavior consistent whether input is piped or redirected.
  local data
  data="$(cat)"
  bytes=$(printf "%s" "$data" | wc -c | tr -d ' ')
  printf "%s" "$data" | "$COP_CMD"
}

copy_from_files() {
  mode="files"
  # Concatenate all files and copy, also count bytes.
  local data
  data="$(cat -- "$@")"
  bytes=$(printf "%s" "$data" | wc -c | tr -d ' ')
  printf "%s" "$data" | "$COP_CMD"
}

show_usage() {
  >&2 printf "\nðŸ“‹ ${BOLD}${GREEN}cop${RESET} ${CYAN}(clipboard helper)${RESET}\n"
  >&2 printf "   Copy text to the system clipboard.\n\n"
  >&2 printf "   ${YELLOW}Usage:${RESET}\n"
  >&2 printf "     â€¢ Pipe or redirect:\n"
  >&2 printf "         some_command | cop\n"
  >&2 printf "         cop < file.txt\n\n"
  >&2 printf "     â€¢ Concatenate files:\n"
  >&2 printf "         cop file1.txt [file2.txt ...]\n\n"
  >&2 printf "   Mode is auto detected based on stdin and arguments.\n\n"
}

# Decide mode:
# - If stdin is not a TTY, something is piped or redirected: use stdin mode.
# - Otherwise, if there are args, treat them as files.
# - If neither, show a short usage message.
if ! [ -t 0 ]; then
  # stdin has data (pipe or redirection)
  copy_from_stdin
elif [ "$#" -gt 0 ]; then
  copy_from_files "$@"
else
  show_usage
  exit 1
fi

# Friendly feedback
if [ "$mode" = "stdin" ]; then
  # stdin mode (pipe or redirection)
  printf "ðŸ“‹ ${BOLD}${GREEN}Copied${RESET} from ${CYAN}stdin${RESET} (%s byte(s)).\n" "$bytes"
else
  # files mode
  printf "ðŸ“‹ ${BOLD}${GREEN}Copied${RESET} from ${CYAN}files${RESET} (%s file(s), %s byte(s)).\n" "$#" "$bytes"
fi
