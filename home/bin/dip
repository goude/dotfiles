#!/usr/bin/env bash
# dip — DoItPoorly shared library for bash scripts
# Source this file or run directly to execute tests on scripts using it.
#
# Usage in scripts:
#   source "$(command -v dip)" || { echo "dip not found" >&2; exit 1; }
#
# Run all tests:
#   dip [--verbose]

# Guard against double-sourcing
[[ -n "${_DIP_LOADED:-}" ]] && return 0
readonly _DIP_LOADED=1

# Library version
readonly DIP_VERSION="0.1.0"

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Shell Safety
# ═══════════════════════════════════════════════════════════════════════════════

# Apply standard safety settings (call explicitly if desired)
dip_strict() {
  set -euo pipefail
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Terminal Detection
# ═══════════════════════════════════════════════════════════════════════════════

# Check if stdout is a terminal
dip_is_tty() {
  [[ -t 1 ]]
}

# Check if stderr is a terminal
dip_is_tty_err() {
  [[ -t 2 ]]
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Color Definitions
# ═══════════════════════════════════════════════════════════════════════════════

# Initialize colors based on terminal capability and NO_COLOR env var
# Call this after sourcing, or colors default to empty strings
dip_init_colors() {
  local force="${1:-}"

  # Reset all to empty first
  C_RESET="" C_BOLD="" C_DIM="" C_ITALIC="" C_UNDERLINE=""
  C_BLACK="" C_RED="" C_GREEN="" C_YELLOW="" C_BLUE="" C_MAGENTA="" C_CYAN="" C_WHITE=""
  C_BRIGHT_BLACK="" C_BRIGHT_RED="" C_BRIGHT_GREEN="" C_BRIGHT_YELLOW=""
  C_BRIGHT_BLUE="" C_BRIGHT_MAGENTA="" C_BRIGHT_CYAN="" C_BRIGHT_WHITE=""
  # Pastel palette (256-color)
  C_ROSE="" C_PEACH="" C_MINT="" C_SKY="" C_LAVENDER="" C_GOLD="" C_CORAL=""

  # Check if colors should be enabled
  if [[ "$force" == "force" ]] || { [[ -z "${NO_COLOR:-}" ]] && dip_is_tty; }; then
    # Reset and styles
    C_RESET=$'\033[0m'
    C_BOLD=$'\033[1m'
    C_DIM=$'\033[2m'
    C_ITALIC=$'\033[3m'
    C_UNDERLINE=$'\033[4m'

    # Standard 16 colors
    C_BLACK=$'\033[30m'
    C_RED=$'\033[31m'
    C_GREEN=$'\033[32m'
    C_YELLOW=$'\033[33m'
    C_BLUE=$'\033[34m'
    C_MAGENTA=$'\033[35m'
    C_CYAN=$'\033[36m'
    C_WHITE=$'\033[37m'

    # Bright variants
    C_BRIGHT_BLACK=$'\033[90m'
    C_BRIGHT_RED=$'\033[91m'
    C_BRIGHT_GREEN=$'\033[92m'
    C_BRIGHT_YELLOW=$'\033[93m'
    C_BRIGHT_BLUE=$'\033[94m'
    C_BRIGHT_MAGENTA=$'\033[95m'
    C_BRIGHT_CYAN=$'\033[96m'
    C_BRIGHT_WHITE=$'\033[97m'

    # Pastel palette (256-color) — matches cop's aesthetic
    C_ROSE=$'\033[38;5;218m'
    C_PEACH=$'\033[38;5;223m'
    C_MINT=$'\033[38;5;158m'
    C_SKY=$'\033[38;5;117m'
    C_LAVENDER=$'\033[38;5;183m'
    C_GOLD=$'\033[38;5;222m'
    C_CORAL=$'\033[38;5;210m'
  fi
}

# Export color variables for subshells if needed
dip_export_colors() {
  export C_RESET C_BOLD C_DIM C_ITALIC C_UNDERLINE
  export C_BLACK C_RED C_GREEN C_YELLOW C_BLUE C_MAGENTA C_CYAN C_WHITE
  export C_BRIGHT_BLACK C_BRIGHT_RED C_BRIGHT_GREEN C_BRIGHT_YELLOW
  export C_BRIGHT_BLUE C_BRIGHT_MAGENTA C_BRIGHT_CYAN C_BRIGHT_WHITE
  export C_ROSE C_PEACH C_MINT C_SKY C_LAVENDER C_GOLD C_CORAL
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Command/Environment Detection
# ═══════════════════════════════════════════════════════════════════════════════

# Check if a command exists
dip_have() {
  command -v "$1" >/dev/null 2>&1
}

# Check if running under Wayland
dip_is_wayland() {
  [[ -n "${WAYLAND_DISPLAY:-}" && -S "/run/user/$(id -u)/${WAYLAND_DISPLAY}" ]]
}

# Check if running under X11
dip_is_x11() {
  [[ -n "${DISPLAY:-}" ]]
}

# Check if inside a git repository
dip_is_git_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

# Get the best available pager/viewer
dip_best_pager() {
  if dip_have bat; then
    printf "bat"
  elif dip_have batcat; then
    printf "batcat"
  elif dip_have less; then
    printf "less"
  else
    printf "cat"
  fi
}

# Get best available cat with syntax highlighting
dip_best_cat() {
  if dip_have bat; then
    printf "bat"
  elif dip_have batcat; then
    printf "batcat"
  else
    printf "cat"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Logging & Output
# ═══════════════════════════════════════════════════════════════════════════════

# Application name for logging (set this in your script)
: "${DIP_APP_NAME:=${0##*/}}"

# Log levels
readonly _DIP_LOG_DEBUG=0
readonly _DIP_LOG_INFO=1
readonly _DIP_LOG_WARN=2
readonly _DIP_LOG_ERROR=3

# Current log level (default: INFO)
: "${DIP_LOG_LEVEL:=$_DIP_LOG_INFO}"

# Internal logging function
_dip_log() {
  local level="$1" prefix="$2" color="$3"
  shift 3
  ((level >= DIP_LOG_LEVEL)) || return 0
  printf "%s%s%s %s%s%s\n" "$color" "$prefix" "$C_RESET" "$color" "$*" "$C_RESET" >&2
}

# Public logging functions
dip_debug() { _dip_log $_DIP_LOG_DEBUG "DEBUG" "$C_DIM" "$@"; }
dip_info()  { _dip_log $_DIP_LOG_INFO  "ℹ"     "$C_CYAN" "$@"; }
dip_warn()  { _dip_log $_DIP_LOG_WARN  "⚠"     "$C_YELLOW" "$@"; }
dip_error() { _dip_log $_DIP_LOG_ERROR "✖"     "$C_RED" "$@"; }

# Log with custom icon (useful for app-specific messaging)
dip_log() {
  local icon="${1:-•}"
  shift
  printf "%s %s%s%s\n" "$icon" "$C_CYAN" "$*" "$C_RESET" >&2
}

# Fatal error: print message and exit
dip_die() {
  local code=1
  if [[ "${1:-}" =~ ^[0-9]+$ ]]; then
    code="$1"
    shift
  fi
  printf "%s✖ %s:%s %s\n" "$C_RED" "$DIP_APP_NAME" "$C_RESET" "$*" >&2
  exit "$code"
}

# Print a horizontal line
dip_hr() {
  local char="${1:-─}" width="${2:-60}" color="${3:-$C_DIM}"
  local line=""
  for ((i = 0; i < width; i++)); do
    line+="$char"
  done
  printf "%s%s%s\n" "$color" "$line" "$C_RESET"
}

# Print a rainbow line (pastel colors)
dip_rainbow_line() {
  local width="${1:-40}"
  local colors=("$C_GOLD" "$C_PEACH" "$C_CORAL" "$C_ROSE" "$C_LAVENDER" "$C_SKY" "$C_MINT")
  local out=""
  for ((i = 0; i < width; i++)); do
    out+="${colors[$((i % ${#colors[@]}))]}━"
  done
  printf "%s%s\n" "$out" "$C_RESET"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Argument Parsing
# ═══════════════════════════════════════════════════════════════════════════════

# Simple argument parser with support for:
#   -s          short flag
#   --long      long flag
#   -s VALUE    short with value
#   --long=VAL  long with value
#   --long VAL  long with value (space-separated)
#   -abc        combined short flags
#
# Usage:
#   dip_parse_args callback "$@"
#
# The callback receives: callback TYPE NAME [VALUE]
#   TYPE: "flag", "opt", "arg", "end"
#   NAME: option name (without dashes) or positional argument
#   VALUE: option value (for "opt" type)
#
# Example callback:
#   handle_arg() {
#     case "$1:$2" in
#       flag:h|flag:help) show_help; exit 0 ;;
#       flag:v|flag:verbose) VERBOSE=1 ;;
#       opt:o|opt:output) OUTPUT="$3" ;;
#       arg:*) POSITIONAL+=("$2") ;;
#     esac
#   }
#   dip_parse_args handle_arg "$@"

dip_parse_args() {
  local callback="$1"
  shift

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --)
        shift
        # Remaining args are positional
        for arg in "$@"; do
          "$callback" "arg" "$arg"
        done
        break
        ;;
      --*=*)
        # --option=value
        local opt="${1#--}"
        local name="${opt%%=*}"
        local value="${opt#*=}"
        "$callback" "opt" "$name" "$value"
        ;;
      --*)
        # --option or --option value
        local name="${1#--}"
        if [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
          # Peek: if next arg doesn't start with -, treat as value
          # But this is ambiguous... let callback decide via convention
          # For simplicity: treat as flag, callback can request next
          "$callback" "flag" "$name"
        else
          "$callback" "flag" "$name"
        fi
        ;;
      -*)
        # Short options: could be -f or -abc (combined) or -f value
        local opts="${1#-}"
        local len=${#opts}
        for ((i = 0; i < len; i++)); do
          local char="${opts:i:1}"
          if ((i == len - 1)) && [[ $# -gt 1 && ! "$2" =~ ^- ]]; then
            # Last char, next arg available and doesn't start with -
            # Could be value; report as flag, let callback handle
            "$callback" "flag" "$char"
          else
            "$callback" "flag" "$char"
          fi
        done
        ;;
      *)
        # Positional argument
        "$callback" "arg" "$1"
        ;;
    esac
    shift
  done

  "$callback" "end" ""
}

# Simpler option parsing for common cases
# Sets variables based on option specs
#
# Usage:
#   declare -A DIP_OPTS=()
#   declare -a DIP_ARGS=()
#   dip_getopt "h,help:flag v,verbose:flag o,output:val" "$@"
#   # Now DIP_OPTS[help], DIP_OPTS[verbose], DIP_OPTS[output] are set
#   # DIP_ARGS contains positional arguments

declare -gA DIP_OPTS=()
declare -ga DIP_ARGS=()

dip_getopt() {
  local spec="$1"
  shift

  DIP_OPTS=()
  DIP_ARGS=()

  # Parse spec into associative arrays
  declare -A short_to_long=()
  declare -A opt_type=()

  local IFS=' '
  for item in $spec; do
    local names="${item%%:*}"
    local type="${item#*:}"
    [[ "$type" == "$item" ]] && type="flag"

    # First pass: find the long name
    local long_name="" short_name=""
    local IFS=','
    for name in $names; do
      if [[ ${#name} -eq 1 ]]; then
        short_name="$name"
      else
        long_name="$name"
      fi
    done

    # Set canonical name (prefer long, fall back to short)
    local canonical="${long_name:-$short_name}"
    
    # Map short to canonical
    [[ -n "$short_name" ]] && short_to_long["$short_name"]="$canonical"
    
    # Set type for canonical name
    opt_type["$canonical"]="$type"
  done

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --)
        shift
        DIP_ARGS+=("$@")
        break
        ;;
      --*=*)
        local opt="${1#--}"
        local name="${opt%%=*}"
        local value="${opt#*=}"
        DIP_OPTS["$name"]="$value"
        ;;
      --no-*)
        local name="${1#--no-}"
        DIP_OPTS["$name"]=""
        ;;
      --*)
        local name="${1#--}"
        if [[ "${opt_type[$name]:-}" == "val" && $# -gt 1 ]]; then
          shift
          DIP_OPTS["$name"]="$1"
        else
          DIP_OPTS["$name"]=1
        fi
        ;;
      -*)
        local opts="${1#-}"
        local len=${#opts}
        for ((i = 0; i < len; i++)); do
          local char="${opts:i:1}"
          local mapped="${short_to_long[$char]:-$char}"
          if [[ "${opt_type[$mapped]:-${opt_type[$char]:-}}" == "val" ]]; then
            if ((i == len - 1)) && [[ $# -gt 1 ]]; then
              shift
              DIP_OPTS["$mapped"]="$1"
            else
              # Value required but not provided
              DIP_OPTS["$mapped"]=""
            fi
          else
            DIP_OPTS["$mapped"]=1
          fi
        done
        ;;
      *)
        DIP_ARGS+=("$1")
        ;;
    esac
    shift
  done
}

# Check if an option was set
dip_opt() {
  [[ -n "${DIP_OPTS[$1]+set}" ]]
}

# Get option value with default
dip_opt_val() {
  local name="$1" default="${2:-}"
  printf "%s" "${DIP_OPTS[$name]:-$default}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Usage/Help Formatting
# ═══════════════════════════════════════════════════════════════════════════════

# Print formatted usage header
dip_usage_header() {
  local name="${1:-$DIP_APP_NAME}"
  local tagline="${2:-}"
  printf "%s%s%s" "$C_BOLD" "$name" "$C_RESET"
  [[ -n "$tagline" ]] && printf " — %s%s%s" "$C_DIM" "$tagline" "$C_RESET"
  printf "\n\n"
}

# Print usage section header
dip_usage_section() {
  printf "%s%s%s\n" "$C_GOLD" "$1" "$C_RESET"
}

# Print formatted option line
dip_usage_opt() {
  local short="${1:-}"
  local long="${2:-}"
  local desc="$3"
  local opt_str=""

  if [[ -n "$short" && -n "$long" ]]; then
    opt_str="  ${C_SKY}-${short}${C_RESET}, ${C_SKY}--${long}${C_RESET}"
  elif [[ -n "$short" ]]; then
    opt_str="  ${C_SKY}-${short}${C_RESET}"
  elif [[ -n "$long" ]]; then
    opt_str="      ${C_SKY}--${long}${C_RESET}"
  fi

  printf "%-32s %s\n" "$opt_str" "$desc"
}

# Print formatted example
dip_usage_example() {
  local cmd="$1"
  local desc="${2:-}"
  printf "  %s%s%s" "$C_DIM" "$cmd" "$C_RESET"
  [[ -n "$desc" ]] && printf "  %s# %s%s" "$C_DIM" "$desc" "$C_RESET"
  printf "\n"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Test Framework
# ═══════════════════════════════════════════════════════════════════════════════

# Test state
declare -g _DIP_TEST_COUNT=0
declare -g _DIP_TEST_PASSED=0
declare -g _DIP_TEST_FAILED=0
declare -g _DIP_TEST_CURRENT=""
declare -g _DIP_TEST_VERBOSE="${DIP_TEST_VERBOSE:-0}"

# Start a test suite
dip_test_suite() {
  local name="$1"
  _DIP_TEST_COUNT=0
  _DIP_TEST_PASSED=0
  _DIP_TEST_FAILED=0
  printf "\n%s━━━ %s ━━━%s\n" "$C_BOLD" "$name" "$C_RESET"
}

# Start a test case
dip_test() {
  local name="$1"
  _DIP_TEST_CURRENT="$name"
  ((_DIP_TEST_COUNT++)) || true
  ((_DIP_TEST_VERBOSE)) && printf "  %s•%s %s... " "$C_DIM" "$C_RESET" "$name"
}

# Test passed
_dip_test_pass() {
  ((_DIP_TEST_PASSED++)) || true
  if ((_DIP_TEST_VERBOSE)); then
    printf "%s✓%s\n" "$C_GREEN" "$C_RESET"
  else
    printf "%s.%s" "$C_GREEN" "$C_RESET"
  fi
}

# Test failed
_dip_test_fail() {
  local msg="$1"
  ((_DIP_TEST_FAILED++)) || true
  if ((_DIP_TEST_VERBOSE)); then
    printf "%s✗%s\n" "$C_RED" "$C_RESET"
    printf "    %s%s%s\n" "$C_RED" "$msg" "$C_RESET"
  else
    printf "%s✗%s" "$C_RED" "$C_RESET"
  fi
}

# Print test summary
dip_test_summary() {
  printf "\n"
  if ((_DIP_TEST_FAILED == 0)); then
    printf "%s✓ All %d tests passed%s\n" "$C_GREEN" "$_DIP_TEST_COUNT" "$C_RESET"
  else
    printf "%s✗ %d/%d tests failed%s\n" "$C_RED" "$_DIP_TEST_FAILED" "$_DIP_TEST_COUNT" "$C_RESET"
  fi
  return "$_DIP_TEST_FAILED"
}

# Assert two values are equal
dip_assert_eq() {
  local msg="$1" got="$2" expect="$3"
  if [[ "$got" == "$expect" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected [$expect], got [$got]"
    return 1
  fi
}

# Assert two values are not equal
dip_assert_ne() {
  local msg="$1" got="$2" not_expect="$3"
  if [[ "$got" != "$not_expect" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected NOT [$not_expect], but got it"
    return 1
  fi
}

# Assert string contains substring
dip_assert_contains() {
  local msg="$1" haystack="$2" needle="$3"
  if [[ "$haystack" == *"$needle"* ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: [$haystack] does not contain [$needle]"
    return 1
  fi
}

# Assert string matches regex
dip_assert_match() {
  local msg="$1" str="$2" pattern="$3"
  if [[ "$str" =~ $pattern ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: [$str] does not match [$pattern]"
    return 1
  fi
}

# Assert command succeeds (exit 0)
dip_assert_ok() {
  local msg="$1"
  shift
  if "$@" >/dev/null 2>&1; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: command failed: $*"
    return 1
  fi
}

# Assert command fails (exit non-zero)
dip_assert_fail() {
  local msg="$1"
  shift
  if "$@" >/dev/null 2>&1; then
    _dip_test_fail "$msg: command succeeded but should fail: $*"
    return 1
  else
    _dip_test_pass
  fi
}

# Assert file exists
dip_assert_file() {
  local msg="$1" path="$2"
  if [[ -f "$path" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: file does not exist: $path"
    return 1
  fi
}

# Assert directory exists
dip_assert_dir() {
  local msg="$1" path="$2"
  if [[ -d "$path" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: directory does not exist: $path"
    return 1
  fi
}

# Assert value is empty
dip_assert_empty() {
  local msg="$1" val="$2"
  if [[ -z "$val" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected empty, got [$val]"
    return 1
  fi
}

# Assert value is not empty
dip_assert_not_empty() {
  local msg="$1" val="$2"
  if [[ -n "$val" ]]; then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected non-empty value"
    return 1
  fi
}

# Assert numeric comparison
dip_assert_lt() {
  local msg="$1" a="$2" b="$3"
  if ((a < b)); then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected $a < $b"
    return 1
  fi
}

dip_assert_le() {
  local msg="$1" a="$2" b="$3"
  if ((a <= b)); then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected $a <= $b"
    return 1
  fi
}

dip_assert_gt() {
  local msg="$1" a="$2" b="$3"
  if ((a > b)); then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected $a > $b"
    return 1
  fi
}

dip_assert_ge() {
  local msg="$1" a="$2" b="$3"
  if ((a >= b)); then
    _dip_test_pass
  else
    _dip_test_fail "$msg: expected $a >= $b"
    return 1
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Utility Functions
# ═══════════════════════════════════════════════════════════════════════════════

# Get the real path of a file (portable)
dip_realpath() {
  local path="$1"
  if dip_have realpath; then
    realpath -- "$path" 2>/dev/null
  elif dip_have python3; then
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$path"
  else
    # Fallback: crude but works for most cases
    (cd "$(dirname "$path")" 2>/dev/null && printf "%s/%s" "$(pwd)" "$(basename "$path")")
  fi
}

# Format bytes to human-readable size
dip_format_size() {
  local bytes="$1"
  if ((bytes >= 1073741824)); then
    printf "%.2f GB" "$(echo "scale=2; $bytes/1073741824" | bc)"
  elif ((bytes >= 1048576)); then
    printf "%.2f MB" "$(echo "scale=2; $bytes/1048576" | bc)"
  elif ((bytes >= 1024)); then
    printf "%.2f kB" "$(echo "scale=2; $bytes/1024" | bc)"
  else
    printf "%d B" "$bytes"
  fi
}

# Prompt for confirmation
dip_confirm() {
  local prompt="${1:-Continue?}" default="${2:-n}"
  local yn

  if [[ "$default" =~ ^[Yy] ]]; then
    prompt="$prompt [Y/n] "
  else
    prompt="$prompt [y/N] "
  fi

  printf "%s" "$prompt" >&2

  if [[ -r /dev/tty ]]; then
    read -r yn </dev/tty
  else
    read -r yn
  fi

  case "$yn" in
    [Yy]*) return 0 ;;
    [Nn]*) return 1 ;;
    "") [[ "$default" =~ ^[Yy] ]] && return 0 || return 1 ;;
    *) return 1 ;;
  esac
}

# Temporary directory with automatic cleanup
dip_mktemp_dir() {
  local prefix="${1:-dip}"
  local dir
  dir=$(mktemp -d -t "${prefix}.XXXXXX")
  # Register cleanup trap (additive)
  trap 'rm -rf "'"$dir"'"' EXIT
  printf "%s" "$dir"
}

# Run a command with a timeout (requires timeout command or we fall back)
dip_timeout() {
  local seconds="$1"
  shift
  if dip_have timeout; then
    timeout "$seconds" "$@"
  else
    # Fallback without timeout
    "$@"
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Self-Test Runner
# ═══════════════════════════════════════════════════════════════════════════════

# Run dip's own internal tests
_dip_self_test() {
  dip_init_colors force
  
  dip_test_suite "dip internal tests"

  # Color initialization
  dip_test "colors initialized"
  dip_assert_not_empty "C_RESET should be set" "$C_RESET"

  # Command detection
  dip_test "dip_have bash"
  dip_assert_ok "bash exists" dip_have bash

  dip_test "dip_have nonexistent_cmd_xyz"
  dip_assert_fail "nonexistent command" dip_have nonexistent_cmd_xyz

  # Format size
  dip_test "dip_format_size bytes"
  dip_assert_eq "512 bytes" "$(dip_format_size 512)" "512 B"

  dip_test "dip_format_size kilobytes"
  dip_assert_match "1024 bytes" "$(dip_format_size 1024)" "^1\.00 kB$"

  dip_test "dip_format_size megabytes"
  dip_assert_match "1MB" "$(dip_format_size 1048576)" "^1\.00 MB$"

  # Option parsing
  dip_test "dip_getopt short flag"
  dip_getopt "v,verbose:flag" -v
  dip_assert_eq "verbose flag" "${DIP_OPTS[verbose]:-}" "1"

  dip_test "dip_getopt long flag"
  dip_getopt "v,verbose:flag" --verbose
  dip_assert_eq "verbose flag" "${DIP_OPTS[verbose]:-}" "1"

  dip_test "dip_getopt value option"
  dip_getopt "o,output:val" -o /tmp/out
  dip_assert_eq "output value" "${DIP_OPTS[output]:-}" "/tmp/out"

  dip_test "dip_getopt long value with ="
  dip_getopt "o,output:val" --output=/tmp/out2
  dip_assert_eq "output value" "${DIP_OPTS[output]:-}" "/tmp/out2"

  dip_test "dip_getopt positional args"
  dip_getopt "v,verbose:flag" -v file1 file2
  dip_assert_eq "first arg" "${DIP_ARGS[0]:-}" "file1"
  dip_assert_eq "second arg" "${DIP_ARGS[1]:-}" "file2"

  dip_test "dip_getopt combined short flags"
  dip_getopt "a:flag b:flag c:flag" -abc
  dip_assert_eq "a flag" "${DIP_OPTS[a]:-}" "1"
  dip_assert_eq "b flag" "${DIP_OPTS[b]:-}" "1"
  dip_assert_eq "c flag" "${DIP_OPTS[c]:-}" "1"

  dip_test "dip_getopt -- separator"
  dip_getopt "v,verbose:flag" -v -- --not-a-flag
  dip_assert_eq "arg after --" "${DIP_ARGS[0]:-}" "--not-a-flag"

  # Assert functions
  dip_test "dip_assert_contains"
  dip_assert_contains "hello world" "hello world" "world"

  dip_test "dip_assert_match"
  dip_assert_match "version string" "v1.2.3" "^v[0-9]+\.[0-9]+\.[0-9]+$"

  dip_test_summary
}

# Find and run tests in scripts that use dip
_dip_run_script_tests() {
  local dir="${1:-.}"
  local verbose="${2:-0}"
  local found=0
  local passed=0
  local failed=0

  dip_init_colors force
  printf "%s━━━ dip test runner ━━━%s\n" "$C_BOLD" "$C_RESET"
  printf "%sSearching for scripts with --test in: %s%s\n\n" "$C_DIM" "$dir" "$C_RESET"

  # Find executable files that source dip and have --test
  while IFS= read -r -d '' script; do
    # Skip dip itself
    [[ "$(basename "$script")" == "dip" ]] && continue

    # Check if it sources dip and has --test handling
    if grep -q 'source.*dip\|--test' "$script" 2>/dev/null; then
      # Check if it has a --test option (look for test pattern)
      if grep -qE '^\s*--test\)|\brun.*test|_test\s*\(\)' "$script" 2>/dev/null; then
        ((found++)) || true
        local name
        name="$(basename "$script")"
        printf "%s▶%s Running tests for %s%s%s\n" "$C_CYAN" "$C_RESET" "$C_BOLD" "$name" "$C_RESET"

        if "$script" --test 2>&1; then
          printf "  %s✓ %s passed%s\n\n" "$C_GREEN" "$name" "$C_RESET"
          ((passed++)) || true
        else
          printf "  %s✗ %s failed%s\n\n" "$C_RED" "$name" "$C_RESET"
          ((failed++)) || true
        fi
      fi
    fi
  done < <(find "$dir" -maxdepth 1 -type f -executable -print0 2>/dev/null)

  printf "%s━━━ Summary ━━━%s\n" "$C_BOLD" "$C_RESET"
  if ((found == 0)); then
    printf "%sNo testable scripts found in %s%s\n" "$C_DIM" "$dir" "$C_RESET"
    printf "%s(Scripts need to source dip and handle --test)%s\n" "$C_DIM" "$C_RESET"
  else
    printf "Found: %d, Passed: %s%d%s, Failed: %s%d%s\n" \
      "$found" \
      "$C_GREEN" "$passed" "$C_RESET" \
      "$C_RED" "$failed" "$C_RESET"
  fi

  return "$failed"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SECTION: Main (when executed directly)
# ═══════════════════════════════════════════════════════════════════════════════

# Only run main if executed, not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Initialize colors for direct execution
  dip_init_colors

  case "${1:-}" in
    --help|-h)
      cat <<EOF
${C_BOLD}dip${C_RESET} — DoItPoorly shared bash library v${DIP_VERSION}

${C_GOLD}Usage:${C_RESET}
  ${C_SKY}source "\$(command -v dip)"${C_RESET}   Source in your script
  ${C_SKY}dip${C_RESET}                         Run tests on scripts in current dir
  ${C_SKY}dip --self-test${C_RESET}             Run dip's internal tests
  ${C_SKY}dip --verbose${C_RESET}               Verbose test output
  ${C_SKY}dip /path/to/dir${C_RESET}            Run tests on scripts in specified dir

${C_GOLD}Features:${C_RESET}
  • Color definitions (standard + pastel palette)
  • Logging functions (debug, info, warn, error, die)
  • Argument parsing (simple and advanced)
  • Test framework (assert_eq, assert_fail, etc.)
  • Utility functions (realpath, format_size, confirm)
  • Usage/help formatting helpers
  • Environment detection (tty, Wayland, X11, git)

${C_GOLD}In your script:${C_RESET}
  ${C_DIM}#!/usr/bin/env bash${C_RESET}
  ${C_DIM}source "\$(command -v dip)" || { echo "dip not found" >&2; exit 1; }${C_RESET}
  ${C_DIM}dip_strict${C_RESET}
  ${C_DIM}dip_init_colors${C_RESET}

${C_GOLD}Test discovery:${C_RESET}
  Scripts in the same directory that:
  1. Are executable
  2. Contain 'source.*dip' or '--test'
  3. Have a --test handler

  Will be discovered and their tests run.

${C_DIM}Made with questionable judgment by doitpoorly${C_RESET}
EOF
      exit 0
      ;;
    --version|-V)
      printf "dip %s\n" "$DIP_VERSION"
      exit 0
      ;;
    --self-test)
      _dip_self_test
      exit $?
      ;;
    --verbose|-v)
      export DIP_TEST_VERBOSE=1
      shift
      dir="${1:-$(dirname "${BASH_SOURCE[0]}")}"
      _dip_self_test
      printf "\n"
      _dip_run_script_tests "$dir" 1
      exit $?
      ;;
    *)
      dir="${1:-$(dirname "${BASH_SOURCE[0]}")}"
      _dip_self_test
      printf "\n"
      _dip_run_script_tests "$dir"
      exit $?
      ;;
  esac
fi
