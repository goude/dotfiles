#!/usr/bin/env bash
set -euo pipefail

# ----- tiny color helpers -----
is_tty=0
[[ -t 1 ]] && is_tty=1

c_reset=""; c_dim=""; c_bold=""; c_red=""; c_green=""; c_cyan=""; c_yellow=""
if [[ "$is_tty" -eq 1 ]] && [[ "${NO_COLOR:-}" == "" ]] ; then
  c_reset=$'\033[0m'
  c_dim=$'\033[2m'
  c_bold=$'\033[1m'
  c_red=$'\033[31m'
  c_green=$'\033[32m'
  c_yellow=$'\033[33m'
  c_cyan=$'\033[36m'
fi

err() { echo "${c_red}giturl:${c_reset} $*" >&2; exit 1; }

usage() {
  cat <<EOF
${c_bold}giturl${c_reset} — print a GitHub URL to a file on the current branch (or commit sha)

${c_bold}Usage${c_reset}
  ${c_cyan}giturl${c_reset} ${c_yellow}<path>${c_reset} ${c_dim}[start_line [end_line]]${c_reset}
  ${c_cyan}giturl${c_reset} ${c_dim}--sha${c_reset} ${c_yellow}<path>${c_reset} ${c_dim}[start_line [end_line]]${c_reset}
  ${c_cyan}giturl${c_reset} ${c_dim}--help${c_reset}

${c_bold}Examples${c_reset}
  ${c_cyan}giturl${c_reset} README.md
  ${c_cyan}giturl${c_reset} tools.js
  ${c_cyan}giturl${c_reset} src/main.py 10
  ${c_cyan}giturl${c_reset} src/main.py 10 42
  ${c_cyan}giturl${c_reset} ${c_dim}--sha${c_reset} tools.js
  ${c_cyan}giturl${c_reset} ${c_dim}--sha${c_reset} src/main.py 10 42

${c_dim}Notes:${c_reset}
  • Paths are interpreted relative to your current directory.
  • Default output uses the current branch name (even if it's main).
  • With --sha, output uses the commit SHA of HEAD (even on a branch).
  • If detached, both modes use the commit SHA.
  • Set NO_COLOR=1 to disable colors.
EOF
}

# ----- args -----
use_sha=0

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  usage
  exit 0
fi

if [[ "${1:-}" == "--sha" ]]; then
  use_sha=1
  shift
fi

[[ $# -ge 1 ]] || { usage; exit 2; }

input_path="$1"
start_line="${2:-}"
end_line="${3:-}"

# ----- repo basics -----
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || err "not inside a git repo"
root="$(git rev-parse --show-toplevel)"

# Resolve the user's path from *current directory*, then convert to repo-relative.
abs_input="$(cd "$PWD" && pwd)/$input_path"
abs_norm="$(
  python3 - <<'PY' "$abs_input"
import os, sys
print(os.path.normpath(sys.argv[1]))
PY
)" || abs_norm="$abs_input"

[[ -e "$abs_norm" ]] || err "no such file: $input_path"

rel="$(
  python3 - <<'PY' "$abs_norm" "$root"
import os, sys
p = os.path.abspath(sys.argv[1])
root = os.path.abspath(sys.argv[2])
try:
    rel = os.path.relpath(p, root)
except ValueError:
    rel = p
# Guard against paths outside repo
if rel.startswith(".."+os.sep) or rel == "..":
    print("", end="")
else:
    print(rel.replace(os.sep, "/"), end="")
PY
)" || rel=""

[[ -n "$rel" ]] || err "path is outside repo: $input_path"

# ----- remote parsing (GitHub only, as requested) -----
remote_url="$(git remote get-url origin 2>/dev/null || true)"
[[ -n "$remote_url" ]] || err "no 'origin' remote found"

case "$remote_url" in
  git@github.com:*.git)       base="https://github.com/${remote_url#git@github.com:}"; base="${base%.git}" ;;
  git@github.com:*)           base="https://github.com/${remote_url#git@github.com:}" ;;
  https://github.com/*.git)   base="${remote_url%.git}" ;;
  https://github.com/*)       base="$remote_url" ;;
  *) err "remote 'origin' is not a GitHub URL: $remote_url" ;;
esac

# ----- choose ref -----
# Default: branch name if possible. With --sha: commit SHA (even on a branch).
branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)"
sha="$(git rev-parse HEAD 2>/dev/null || true)"
[[ -n "$sha" ]] || err "could not resolve HEAD"

if [[ "$use_sha" -eq 1 ]]; then
  ref="$sha"
else
  if [[ -n "$branch" ]]; then
    ref="$branch"
  else
    ref="$sha"
  fi
fi

url="$base/blob/$ref/$rel"

# Optional line fragment
if [[ -n "$start_line" ]]; then
  [[ "$start_line" =~ ^[0-9]+$ ]] || err "start_line must be an integer"
  if [[ -n "$end_line" ]]; then
    [[ "$end_line" =~ ^[0-9]+$ ]] || err "end_line must be an integer"
    url="${url}#L${start_line}-L${end_line}"
  else
    url="${url}#L${start_line}"
  fi
fi

echo "$url"